{
  "version": 3,
  "sources": ["optional-peer-dep:__vite-optional-peer-dep:next/image:@splinetool/react-spline", "../../@splinetool/react-spline/dist/react-spline-next.js", "../../blurhash/src/base83.ts", "../../blurhash/src/utils.ts", "../../blurhash/src/error.ts", "../../blurhash/src/decode.ts", "../../blurhash/src/encode.ts", "../../thumbhash/thumbhash.js", "../../@splinetool/react-spline/dist/next/decodePreview.js"],
  "sourcesContent": ["throw new Error(`Could not resolve \"next/image\" imported by \"@splinetool/react-spline\". Is it installed?`)", "import { jsx as h, Fragment as o } from \"react/jsx-runtime\";\nimport { decodePreview as a } from \"./next/decodePreview.js\";\nimport p from \"next/image\";\nimport d from \"./react-spline.js\";\nasync function l(n) {\n  const t = /^https:\\/\\/([^\\/]+).spline.design\\/([^\\/]+)\\/scene.splinecode/gi.exec(\n    n\n  );\n  let i = {};\n  if (t != null && t[2]) {\n    const s = t[1], r = t[2];\n    try {\n      const e = await (await fetch(`https://${s}.spline.design/${r}/hash`, {\n        cache: process.env.NODE_ENV === \"production\" ? \"force-cache\" : \"no-store\"\n      })).json();\n      Object.assign(i, e), i.img = a(e.hash, e.alpha, e.width, e.height);\n    } catch (c) {\n      console.error(c);\n    }\n  }\n  return i;\n}\nasync function u({ ...n }) {\n  const {\n    hash: t,\n    img: i,\n    frameWidth: s,\n    frameHeight: r,\n    width: c,\n    height: e\n  } = await l(n.scene);\n  return /* @__PURE__ */ h(o, { children: /* @__PURE__ */ h(d, { ...n, children: i && /* @__PURE__ */ h(\n    p,\n    {\n      src: i,\n      alt: \"Spline preview\",\n      style: {\n        width: s ? s + \"px\" : \"100%\",\n        height: r ? r + \"px\" : \"100%\"\n      },\n      width: c ?? 100,\n      height: e ?? 100\n    }\n  ) }) });\n}\nexport {\n  u as default\n};\n", "const digitCharacters = [\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"#\",\n  \"$\",\n  \"%\",\n  \"*\",\n  \"+\",\n  \",\",\n  \"-\",\n  \".\",\n  \":\",\n  \";\",\n  \"=\",\n  \"?\",\n  \"@\",\n  \"[\",\n  \"]\",\n  \"^\",\n  \"_\",\n  \"{\",\n  \"|\",\n  \"}\",\n  \"~\",\n];\n\nexport const decode83 = (str: String) => {\n  let value = 0;\n  for (let i = 0; i < str.length; i++) {\n    const c = str[i];\n    const digit = digitCharacters.indexOf(c);\n    value = value * 83 + digit;\n  }\n  return value;\n};\n\nexport const encode83 = (n: number, length: number): string => {\n  var result = \"\";\n  for (let i = 1; i <= length; i++) {\n    let digit = (Math.floor(n) / Math.pow(83, length - i)) % 83;\n    result += digitCharacters[Math.floor(digit)];\n  }\n  return result;\n};\n", "export const sRGBToLinear = (value: number) => {\n  let v = value / 255;\n  if (v <= 0.04045) {\n    return v / 12.92;\n  } else {\n    return Math.pow((v + 0.055) / 1.055, 2.4);\n  }\n};\n\nexport const linearTosRGB = (value: number) => {\n  let v = Math.max(0, Math.min(1, value));\n  if (v <= 0.0031308) {\n    return Math.trunc(v * 12.92 * 255 + 0.5);\n  } else {\n    return Math.trunc((1.055 * Math.pow(v, 1 / 2.4) - 0.055) * 255 + 0.5);\n  }\n};\n\nexport const sign = (n: number) => (n < 0 ? -1 : 1);\n\nexport const signPow = (val: number, exp: number) =>\n  sign(val) * Math.pow(Math.abs(val), exp);\n", "export class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n    this.message = message;\n  }\n}\n", "import { decode83 } from \"./base83\";\nimport { sRGBToLinear, signPow, linearTosRGB } from \"./utils\";\nimport { ValidationError } from \"./error\";\n\n/**\n * Returns an error message if invalid or undefined if valid\n * @param blurhash\n */\nconst validateBlurhash = (blurhash: string) => {\n  if (!blurhash || blurhash.length < 6) {\n    throw new ValidationError(\n      \"The blurhash string must be at least 6 characters\"\n    );\n  }\n\n  const sizeFlag = decode83(blurhash[0]);\n  const numY = Math.floor(sizeFlag / 9) + 1;\n  const numX = (sizeFlag % 9) + 1;\n\n  if (blurhash.length !== 4 + 2 * numX * numY) {\n    throw new ValidationError(\n      `blurhash length mismatch: length is ${\n        blurhash.length\n      } but it should be ${4 + 2 * numX * numY}`\n    );\n  }\n};\n\nexport const isBlurhashValid = (\n  blurhash: string\n): { result: boolean; errorReason?: string } => {\n  try {\n    validateBlurhash(blurhash);\n  } catch (error) {\n    return { result: false, errorReason: error.message };\n  }\n\n  return { result: true };\n};\n\nconst decodeDC = (value: number) => {\n  const intR = value >> 16;\n  const intG = (value >> 8) & 255;\n  const intB = value & 255;\n  return [sRGBToLinear(intR), sRGBToLinear(intG), sRGBToLinear(intB)];\n};\n\nconst decodeAC = (value: number, maximumValue: number) => {\n  const quantR = Math.floor(value / (19 * 19));\n  const quantG = Math.floor(value / 19) % 19;\n  const quantB = value % 19;\n\n  const rgb = [\n    signPow((quantR - 9) / 9, 2.0) * maximumValue,\n    signPow((quantG - 9) / 9, 2.0) * maximumValue,\n    signPow((quantB - 9) / 9, 2.0) * maximumValue,\n  ];\n\n  return rgb;\n};\n\nconst decode = (\n  blurhash: string,\n  width: number,\n  height: number,\n  punch?: number\n) => {\n  validateBlurhash(blurhash);\n\n  punch = punch | 1;\n\n  const sizeFlag = decode83(blurhash[0]);\n  const numY = Math.floor(sizeFlag / 9) + 1;\n  const numX = (sizeFlag % 9) + 1;\n\n  const quantisedMaximumValue = decode83(blurhash[1]);\n  const maximumValue = (quantisedMaximumValue + 1) / 166;\n\n  const colors = new Array(numX * numY);\n\n  for (let i = 0; i < colors.length; i++) {\n    if (i === 0) {\n      const value = decode83(blurhash.substring(2, 6));\n      colors[i] = decodeDC(value);\n    } else {\n      const value = decode83(blurhash.substring(4 + i * 2, 6 + i * 2));\n      colors[i] = decodeAC(value, maximumValue * punch);\n    }\n  }\n\n  const bytesPerRow = width * 4;\n  const pixels = new Uint8ClampedArray(bytesPerRow * height);\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let r = 0;\n      let g = 0;\n      let b = 0;\n\n      for (let j = 0; j < numY; j++) {\n        for (let i = 0; i < numX; i++) {\n          const basis =\n            Math.cos((Math.PI * x * i) / width) *\n            Math.cos((Math.PI * y * j) / height);\n          let color = colors[i + j * numX];\n          r += color[0] * basis;\n          g += color[1] * basis;\n          b += color[2] * basis;\n        }\n      }\n\n      let intR = linearTosRGB(r);\n      let intG = linearTosRGB(g);\n      let intB = linearTosRGB(b);\n\n      pixels[4 * x + 0 + y * bytesPerRow] = intR;\n      pixels[4 * x + 1 + y * bytesPerRow] = intG;\n      pixels[4 * x + 2 + y * bytesPerRow] = intB;\n      pixels[4 * x + 3 + y * bytesPerRow] = 255; // alpha\n    }\n  }\n  return pixels;\n};\n\nexport default decode;\n", "import { encode83 } from \"./base83\";\nimport { sRGBToLinear, signPow, linearTosRGB } from \"./utils\";\nimport { ValidationError } from \"./error\";\n\ntype NumberTriplet = [number, number, number];\n\nconst bytesPerPixel = 4;\n\nconst multiplyBasisFunction = (\n  pixels: Uint8ClampedArray,\n  width: number,\n  height: number,\n  basisFunction: (i: number, j: number) => number\n): NumberTriplet => {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  const bytesPerRow = width * bytesPerPixel;\n\n  for (let x = 0; x < width; x++) {\n    const bytesPerPixelX = bytesPerPixel * x;\n\n    for (let y = 0; y < height; y++) {\n      const basePixelIndex = bytesPerPixelX + y * bytesPerRow;\n      const basis = basisFunction(x, y);\n      r +=\n        basis * sRGBToLinear(pixels[basePixelIndex]);\n      g +=\n        basis * sRGBToLinear(pixels[basePixelIndex + 1]);\n      b +=\n        basis * sRGBToLinear(pixels[basePixelIndex + 2]);\n    }\n  }\n\n  let scale = 1 / (width * height);\n\n  return [r * scale, g * scale, b * scale];\n};\n\nconst encodeDC = (value: NumberTriplet): number => {\n  const roundedR = linearTosRGB(value[0]);\n  const roundedG = linearTosRGB(value[1]);\n  const roundedB = linearTosRGB(value[2]);\n  return (roundedR << 16) + (roundedG << 8) + roundedB;\n};\n\nconst encodeAC = (value: NumberTriplet, maximumValue: number): number => {\n  let quantR = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[0] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n  let quantG = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[1] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n  let quantB = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[2] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n\n  return quantR * 19 * 19 + quantG * 19 + quantB;\n};\n\nconst encode = (\n  pixels: Uint8ClampedArray,\n  width: number,\n  height: number,\n  componentX: number,\n  componentY: number\n): string => {\n  if (componentX < 1 || componentX > 9 || componentY < 1 || componentY > 9) {\n    throw new ValidationError(\"BlurHash must have between 1 and 9 components\");\n  }\n  if (width * height * 4 !== pixels.length) {\n    throw new ValidationError(\"Width and height must match the pixels array\");\n  }\n\n  let factors: Array<[number, number, number]> = [];\n  for (let y = 0; y < componentY; y++) {\n    for (let x = 0; x < componentX; x++) {\n      const normalisation = x == 0 && y == 0 ? 1 : 2;\n      const factor = multiplyBasisFunction(\n        pixels,\n        width,\n        height,\n        (i: number, j: number) =>\n          normalisation *\n          Math.cos((Math.PI * x * i) / width) *\n          Math.cos((Math.PI * y * j) / height)\n      );\n      factors.push(factor);\n    }\n  }\n\n  const dc = factors[0];\n  const ac = factors.slice(1);\n\n  let hash = \"\";\n\n  let sizeFlag = componentX - 1 + (componentY - 1) * 9;\n  hash += encode83(sizeFlag, 1);\n\n  let maximumValue: number;\n  if (ac.length > 0) {\n    let actualMaximumValue = Math.max(...ac.map((val) => Math.max(...val)));\n    let quantisedMaximumValue = Math.floor(\n      Math.max(0, Math.min(82, Math.floor(actualMaximumValue * 166 - 0.5)))\n    );\n    maximumValue = (quantisedMaximumValue + 1) / 166;\n    hash += encode83(quantisedMaximumValue, 1);\n  } else {\n    maximumValue = 1;\n    hash += encode83(0, 1);\n  }\n\n  hash += encode83(encodeDC(dc), 4);\n\n  ac.forEach((factor) => {\n    hash += encode83(encodeAC(factor, maximumValue), 2);\n  });\n\n  return hash;\n};\n\nexport default encode;\n", "/**\n * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns The ThumbHash as a Uint8Array.\n */\nexport function rgbaToThumbHash(w, h, rgba) {\n  // Encoding an image larger than 100x100 is slow with no benefit\n  if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`)\n  let { PI, round, max, cos, abs } = Math\n\n  // Determine the average color\n  let avg_r = 0, avg_g = 0, avg_b = 0, avg_a = 0\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    avg_r += alpha / 255 * rgba[j]\n    avg_g += alpha / 255 * rgba[j + 1]\n    avg_b += alpha / 255 * rgba[j + 2]\n    avg_a += alpha\n  }\n  if (avg_a) {\n    avg_r /= avg_a\n    avg_g /= avg_a\n    avg_b /= avg_a\n  }\n\n  let hasAlpha = avg_a < w * h\n  let l_limit = hasAlpha ? 5 : 7 // Use fewer luminance bits if there's alpha\n  let lx = max(1, round(l_limit * w / max(w, h)))\n  let ly = max(1, round(l_limit * h / max(w, h)))\n  let l = [] // luminance\n  let p = [] // yellow - blue\n  let q = [] // red - green\n  let a = [] // alpha\n\n  // Convert the image from RGBA to LPQA (composite atop the average color)\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    let r = avg_r * (1 - alpha) + alpha / 255 * rgba[j]\n    let g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1]\n    let b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2]\n    l[i] = (r + g + b) / 3\n    p[i] = (r + g) / 2 - b\n    q[i] = r - g\n    a[i] = alpha\n  }\n\n  // Encode using the DCT into DC (constant) and normalized AC (varying) terms\n  let encodeChannel = (channel, nx, ny) => {\n    let dc = 0, ac = [], scale = 0, fx = []\n    for (let cy = 0; cy < ny; cy++) {\n      for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {\n        let f = 0\n        for (let x = 0; x < w; x++)\n          fx[x] = cos(PI / w * cx * (x + 0.5))\n        for (let y = 0; y < h; y++)\n          for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++)\n            f += channel[x + y * w] * fx[x] * fy\n        f /= w * h\n        if (cx || cy) {\n          ac.push(f)\n          scale = max(scale, abs(f))\n        } else {\n          dc = f\n        }\n      }\n    }\n    if (scale)\n      for (let i = 0; i < ac.length; i++)\n        ac[i] = 0.5 + 0.5 / scale * ac[i]\n    return [dc, ac, scale]\n  }\n  let [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly))\n  let [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3)\n  let [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3)\n  let [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : []\n\n  // Write the constants\n  let isLandscape = w > h\n  let header24 = round(63 * l_dc) | (round(31.5 + 31.5 * p_dc) << 6) | (round(31.5 + 31.5 * q_dc) << 12) | (round(31 * l_scale) << 18) | (hasAlpha << 23)\n  let header16 = (isLandscape ? ly : lx) | (round(63 * p_scale) << 3) | (round(63 * q_scale) << 9) | (isLandscape << 15)\n  let hash = [header24 & 255, (header24 >> 8) & 255, header24 >> 16, header16 & 255, header16 >> 8]\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  if (hasAlpha) hash.push(round(15 * a_dc) | (round(15 * a_scale) << 4))\n\n  // Write the varying factors\n  for (let ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac])\n    for (let f of ac)\n      hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2)\n  return new Uint8Array(hash)\n}\n\n/**\n * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The width, height, and pixels of the rendered placeholder image.\n */\nexport function thumbHashToRGBA(hash) {\n  let { PI, min, max, cos, round } = Math\n\n  // Read the constants\n  let header24 = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let header16 = hash[3] | (hash[4] << 8)\n  let l_dc = (header24 & 63) / 63\n  let p_dc = ((header24 >> 6) & 63) / 31.5 - 1\n  let q_dc = ((header24 >> 12) & 63) / 31.5 - 1\n  let l_scale = ((header24 >> 18) & 31) / 31\n  let hasAlpha = header24 >> 23\n  let p_scale = ((header16 >> 3) & 63) / 63\n  let q_scale = ((header16 >> 9) & 63) / 63\n  let isLandscape = header16 >> 15\n  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7)\n  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7)\n  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let a_scale = (hash[5] >> 4) / 15\n\n  // Read the varying factors (boost saturation by 1.25x to compensate for quantization)\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  let decodeChannel = (nx, ny, scale) => {\n    let ac = []\n    for (let cy = 0; cy < ny; cy++)\n      for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++)\n        ac.push((((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2)) & 15) / 7.5 - 1) * scale)\n    return ac\n  }\n  let l_ac = decodeChannel(lx, ly, l_scale)\n  let p_ac = decodeChannel(3, 3, p_scale * 1.25)\n  let q_ac = decodeChannel(3, 3, q_scale * 1.25)\n  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale)\n\n  // Decode using the DCT into RGB\n  let ratio = thumbHashToApproximateAspectRatio(hash)\n  let w = round(ratio > 1 ? 32 : 32 * ratio)\n  let h = round(ratio > 1 ? 32 / ratio : 32)\n  let rgba = new Uint8Array(w * h * 4), fx = [], fy = []\n  for (let y = 0, i = 0; y < h; y++) {\n    for (let x = 0; x < w; x++, i += 4) {\n      let l = l_dc, p = p_dc, q = q_dc, a = a_dc\n\n      // Precompute the coefficients\n      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++)\n        fx[cx] = cos(PI / w * (x + 0.5) * cx)\n      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++)\n        fy[cy] = cos(PI / h * (y + 0.5) * cy)\n\n      // Decode L\n      for (let cy = 0, j = 0; cy < ly; cy++)\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++)\n          l += l_ac[j] * fx[cx] * fy2\n\n      // Decode P and Q\n      for (let cy = 0, j = 0; cy < 3; cy++) {\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {\n          let f = fx[cx] * fy2\n          p += p_ac[j] * f\n          q += q_ac[j] * f\n        }\n      }\n\n      // Decode A\n      if (hasAlpha)\n        for (let cy = 0, j = 0; cy < 5; cy++)\n          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++)\n            a += a_ac[j] * fx[cx] * fy2\n\n      // Convert to RGB\n      let b = l - 2 / 3 * p\n      let r = (3 * l - b + q) / 2\n      let g = r - q\n      rgba[i] = max(0, 255 * min(1, r))\n      rgba[i + 1] = max(0, 255 * min(1, g))\n      rgba[i + 2] = max(0, 255 * min(1, b))\n      rgba[i + 3] = max(0, 255 * min(1, a))\n    }\n  }\n  return { w, h, rgba }\n}\n\n/**\n * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The RGBA values for the average color. Each value ranges from 0 to 1.\n */\nexport function thumbHashToAverageRGBA(hash) {\n  let { min, max } = Math\n  let header = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let l = (header & 63) / 63\n  let p = ((header >> 6) & 63) / 31.5 - 1\n  let q = ((header >> 12) & 63) / 31.5 - 1\n  let hasAlpha = header >> 23\n  let a = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let b = l - 2 / 3 * p\n  let r = (3 * l - b + q) / 2\n  let g = r - q\n  return {\n    r: max(0, min(1, r)),\n    g: max(0, min(1, g)),\n    b: max(0, min(1, b)),\n    a\n  }\n}\n\n/**\n * Extracts the approximate aspect ratio of the original image.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The approximate aspect ratio (i.e. width / height).\n */\nexport function thumbHashToApproximateAspectRatio(hash) {\n  let header = hash[3]\n  let hasAlpha = hash[2] & 0x80\n  let isLandscape = hash[4] & 0x80\n  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7\n  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7\n  return lx / ly\n}\n\n/**\n * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by\n * A. This is optimized for speed and simplicity and does not optimize for size\n * at all. This doesn't do any compression (all values are stored uncompressed).\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns A data URL containing a PNG for the input image.\n */\nexport function rgbaToDataURL(w, h, rgba) {\n  let row = w * 4 + 1\n  let idat = 6 + h * (5 + row)\n  let bytes = [\n    137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0,\n    w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0,\n    idat >>> 24, (idat >> 16) & 255, (idat >> 8) & 255, idat & 255,\n    73, 68, 65, 84, 120, 1\n  ]\n  let table = [\n    0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960,\n    1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376,\n    -2032938284, -1609899400, -1111625188\n  ]\n  let a = 1, b = 0\n  for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {\n    bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, (row >> 8) ^ 255, 0)\n    for (b = (b + a) % 65521; i < end; i++) {\n      let u = rgba[i] & 255\n      bytes.push(u)\n      a = (a + u) % 65521\n      b = (b + a) % 65521\n    }\n  }\n  bytes.push(\n    b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0,\n    0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n  )\n  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {\n    let c = ~0\n    for (let i = start; i < end; i++) {\n      c ^= bytes[i]\n      c = (c >>> 4) ^ table[c & 15]\n      c = (c >>> 4) ^ table[c & 15]\n    }\n    c = ~c\n    bytes[end++] = c >>> 24\n    bytes[end++] = (c >> 16) & 255\n    bytes[end++] = (c >> 8) & 255\n    bytes[end++] = c & 255\n  }\n  return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes))\n}\n\n/**\n * Decodes a ThumbHash to a PNG data URL. This is a convenience function that\n * just calls \"thumbHashToRGBA\" followed by \"rgbaToDataURL\".\n *\n * @param hash The bytes of the ThumbHash.\n * @returns A data URL containing a PNG for the rendered ThumbHash.\n */\nexport function thumbHashToDataURL(hash) {\n  let image = thumbHashToRGBA(hash)\n  return rgbaToDataURL(image.w, image.h, image.rgba)\n}\n", "import { decode as y } from \"blurhash\";\nimport * as U from \"thumbhash\";\nfunction X(t, i = !1, o = 100, c = 100) {\n  return i ? U.thumbHashToDataURL(N(t)) : O(t, o, c);\n}\nfunction N(t) {\n  return new Uint8Array(\n    atob(t).split(\"\").map((i) => i.charCodeAt(0))\n  );\n}\nfunction O(t, i = 100, o = 100) {\n  if (!t)\n    return;\n  const c = y(t, i, o);\n  return M(c, i, o);\n}\nfunction M(t, i, o) {\n  const c = [...t].map((d) => String.fromCharCode(d)).join(\"\"), l = B(i, o, c);\n  return \"data:image/png;base64,\" + (typeof Buffer < \"u\" ? Buffer.from(x(l)).toString(\"base64\") : btoa(l));\n}\nfunction x(t) {\n  const i = new Uint8Array(t.length);\n  for (let o = 0; o < t.length; o++)\n    i[o] = t.charCodeAt(o);\n  return i;\n}\nfunction B(t, i, o) {\n  const c = \"x\u0001\", l = [], T = `PNG\\r\n\u001A\n`, d = \"\\0\";\n  let C, s, h;\n  for (C = 0; C < 256; C++) {\n    for (s = C, h = 0; h < 8; h++)\n      s & 1 ? s = 3988292384 ^ s >>> 1 : s = s >>> 1;\n    l[C] = s;\n  }\n  function E(r) {\n    let n = \"\", e, f;\n    for (let g = 0; g < r.length; g += 65535)\n      e = r.length - g, f = \"\", e <= 65535 ? f = \"\u0001\" : (e = 65535, f = \"\\0\"), n += f + String.fromCharCode(e & 255, (e & 65280) >>> 8), n += String.fromCharCode(\n        ~e & 255,\n        (~e & 65280) >>> 8\n      ), n += r.substring(g, g + e);\n    return n;\n  }\n  function p(r) {\n    let a = 65521, n = 1, e = 0;\n    for (let f = 0; f < r.length; f++)\n      n = (n + r.charCodeAt(f)) % a, e = (e + n) % a;\n    return e << 16 | n;\n  }\n  function D(r, a) {\n    let n = r, e;\n    for (let f = 0; f < a.length; f++)\n      e = a.charCodeAt(f), n = l[(n ^ e) & 255] ^ n >>> 8;\n    return n;\n  }\n  function L(r) {\n    return D(4294967295, r) ^ 4294967295;\n  }\n  function u(r) {\n    return String.fromCharCode(\n      (r & 4278190080) >>> 24,\n      (r & 16711680) >>> 16,\n      (r & 65280) >>> 8,\n      r & 255\n    );\n  }\n  function S(r, a, n) {\n    const e = L(a + n);\n    return u(r) + a + n + u(e);\n  }\n  function H(r, a) {\n    const n = u(r) + u(a) + // bit depth\n    \"\\b\u0006\\0\\0\\0\";\n    return S(13, \"IHDR\", n);\n  }\n  const _ = S(0, \"IEND\", \"\"), I = H(t, i);\n  let A = \"\", m;\n  for (let r = 0; r < o.length; r += t * 4) {\n    if (m = d, Array.isArray(o))\n      for (let a = 0; a < t * 4; a++)\n        m += String.fromCharCode(o[r + a] & 255);\n    else\n      m += o.substr(r, t * 4);\n    A += m;\n  }\n  const R = c + E(A) + u(p(A)), b = S(\n    R.length,\n    \"IDAT\",\n    R\n  );\n  return T + I + b + _;\n}\nexport {\n  X as decodePreview\n};\n"],
  "mappings": "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",
  "names": ["l", "C", "l", "C", "u", "o", "B", "h", "x", "l", "p", "q", "j", "f", "h", "u", "o", "M", "d", "l", "x", "C", "h", "f", "p", "L", "u", "h", "o", "p"]
}
