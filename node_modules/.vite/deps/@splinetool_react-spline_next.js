import {
  C
} from "./chunk-HM4VAUBZ.js";
import {
  require_jsx_runtime
} from "./chunk-NAXKE64U.js";
import "./chunk-HPJJ3TUJ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-SNAQBZPT.js";

// optional-peer-dep:__vite-optional-peer-dep:next/image:@splinetool/react-spline
var require_react_spline = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:next/image:@splinetool/react-spline"() {
    throw new Error(`Could not resolve "next/image" imported by "@splinetool/react-spline". Is it installed?`);
  }
});

// node_modules/@splinetool/react-spline/dist/react-spline-next.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/blurhash/dist/esm/index.js
var q = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "#", "$", "%", "*", "+", ",", "-", ".", ":", ";", "=", "?", "@", "[", "]", "^", "_", "{", "|", "}", "~"];
var x = (t) => {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    let n = t[r], l2 = q.indexOf(n);
    e = e * 83 + l2;
  }
  return e;
};
var f = (t) => {
  let e = t / 255;
  return e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
};
var h = (t) => {
  let e = Math.max(0, Math.min(1, t));
  return e <= 31308e-7 ? Math.trunc(e * 12.92 * 255 + 0.5) : Math.trunc((1.055 * Math.pow(e, 0.4166666666666667) - 0.055) * 255 + 0.5);
};
var F = (t) => t < 0 ? -1 : 1;
var M = (t, e) => F(t) * Math.pow(Math.abs(t), e);
var d = class extends Error {
  constructor(e) {
    super(e), this.name = "ValidationError", this.message = e;
  }
};
var C2 = (t) => {
  if (!t || t.length < 6) throw new d("The blurhash string must be at least 6 characters");
  let e = x(t[0]), r = Math.floor(e / 9) + 1, n = e % 9 + 1;
  if (t.length !== 4 + 2 * n * r) throw new d(`blurhash length mismatch: length is ${t.length} but it should be ${4 + 2 * n * r}`);
};
var z = (t) => {
  let e = t >> 16, r = t >> 8 & 255, n = t & 255;
  return [f(e), f(r), f(n)];
};
var L = (t, e) => {
  let r = Math.floor(t / 361), n = Math.floor(t / 19) % 19, l2 = t % 19;
  return [M((r - 9) / 9, 2) * e, M((n - 9) / 9, 2) * e, M((l2 - 9) / 9, 2) * e];
};
var U = (t, e, r, n) => {
  C2(t), n = n | 1;
  let l2 = x(t[0]), m = Math.floor(l2 / 9) + 1, b = l2 % 9 + 1, i = (x(t[1]) + 1) / 166, u2 = new Array(b * m);
  for (let o2 = 0; o2 < u2.length; o2++) if (o2 === 0) {
    let a = x(t.substring(2, 6));
    u2[o2] = z(a);
  } else {
    let a = x(t.substring(4 + o2 * 2, 6 + o2 * 2));
    u2[o2] = L(a, i * n);
  }
  let c = e * 4, s = new Uint8ClampedArray(c * r);
  for (let o2 = 0; o2 < r; o2++) for (let a = 0; a < e; a++) {
    let y = 0, B2 = 0, R = 0;
    for (let w = 0; w < m; w++) for (let P = 0; P < b; P++) {
      let G = Math.cos(Math.PI * a * P / e) * Math.cos(Math.PI * o2 * w / r), T = u2[P + w * b];
      y += T[0] * G, B2 += T[1] * G, R += T[2] * G;
    }
    let V = h(y), I = h(B2), E = h(R);
    s[4 * a + 0 + o2 * c] = V, s[4 * a + 1 + o2 * c] = I, s[4 * a + 2 + o2 * c] = E, s[4 * a + 3 + o2 * c] = 255;
  }
  return s;
};
var j = U;

// node_modules/thumbhash/thumbhash.js
function thumbHashToRGBA(hash) {
  let { PI, min, max, cos, round } = Math;
  let header24 = hash[0] | hash[1] << 8 | hash[2] << 16;
  let header16 = hash[3] | hash[4] << 8;
  let l_dc = (header24 & 63) / 63;
  let p_dc = (header24 >> 6 & 63) / 31.5 - 1;
  let q_dc = (header24 >> 12 & 63) / 31.5 - 1;
  let l_scale = (header24 >> 18 & 31) / 31;
  let hasAlpha = header24 >> 23;
  let p_scale = (header16 >> 3 & 63) / 63;
  let q_scale = (header16 >> 9 & 63) / 63;
  let isLandscape = header16 >> 15;
  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7);
  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7);
  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1;
  let a_scale = (hash[5] >> 4) / 15;
  let ac_start = hasAlpha ? 6 : 5;
  let ac_index = 0;
  let decodeChannel = (nx, ny, scale) => {
    let ac = [];
    for (let cy = 0; cy < ny; cy++)
      for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++)
        ac.push(((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2) & 15) / 7.5 - 1) * scale);
    return ac;
  };
  let l_ac = decodeChannel(lx, ly, l_scale);
  let p_ac = decodeChannel(3, 3, p_scale * 1.25);
  let q_ac = decodeChannel(3, 3, q_scale * 1.25);
  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale);
  let ratio = thumbHashToApproximateAspectRatio(hash);
  let w = round(ratio > 1 ? 32 : 32 * ratio);
  let h3 = round(ratio > 1 ? 32 / ratio : 32);
  let rgba = new Uint8Array(w * h3 * 4), fx = [], fy = [];
  for (let y = 0, i = 0; y < h3; y++) {
    for (let x3 = 0; x3 < w; x3++, i += 4) {
      let l2 = l_dc, p2 = p_dc, q2 = q_dc, a = a_dc;
      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++)
        fx[cx] = cos(PI / w * (x3 + 0.5) * cx);
      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++)
        fy[cy] = cos(PI / h3 * (y + 0.5) * cy);
      for (let cy = 0, j2 = 0; cy < ly; cy++)
        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j2++)
          l2 += l_ac[j2] * fx[cx] * fy2;
      for (let cy = 0, j2 = 0; cy < 3; cy++) {
        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j2++) {
          let f2 = fx[cx] * fy2;
          p2 += p_ac[j2] * f2;
          q2 += q_ac[j2] * f2;
        }
      }
      if (hasAlpha)
        for (let cy = 0, j2 = 0; cy < 5; cy++)
          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j2++)
            a += a_ac[j2] * fx[cx] * fy2;
      let b = l2 - 2 / 3 * p2;
      let r = (3 * l2 - b + q2) / 2;
      let g = r - q2;
      rgba[i] = max(0, 255 * min(1, r));
      rgba[i + 1] = max(0, 255 * min(1, g));
      rgba[i + 2] = max(0, 255 * min(1, b));
      rgba[i + 3] = max(0, 255 * min(1, a));
    }
  }
  return { w, h: h3, rgba };
}
function thumbHashToApproximateAspectRatio(hash) {
  let header = hash[3];
  let hasAlpha = hash[2] & 128;
  let isLandscape = hash[4] & 128;
  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7;
  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7;
  return lx / ly;
}
function rgbaToDataURL(w, h3, rgba) {
  let row = w * 4 + 1;
  let idat = 6 + h3 * (5 + row);
  let bytes = [
    137,
    80,
    78,
    71,
    13,
    10,
    26,
    10,
    0,
    0,
    0,
    13,
    73,
    72,
    68,
    82,
    0,
    0,
    w >> 8,
    w & 255,
    0,
    0,
    h3 >> 8,
    h3 & 255,
    8,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    idat >>> 24,
    idat >> 16 & 255,
    idat >> 8 & 255,
    idat & 255,
    73,
    68,
    65,
    84,
    120,
    1
  ];
  let table = [
    0,
    498536548,
    997073096,
    651767980,
    1994146192,
    1802195444,
    1303535960,
    1342533948,
    -306674912,
    -267414716,
    -690576408,
    -882789492,
    -1687895376,
    -2032938284,
    -1609899400,
    -1111625188
  ];
  let a = 1, b = 0;
  for (let y = 0, i = 0, end = row - 1; y < h3; y++, end += row - 1) {
    bytes.push(y + 1 < h3 ? 0 : 1, row & 255, row >> 8, ~row & 255, row >> 8 ^ 255, 0);
    for (b = (b + a) % 65521; i < end; i++) {
      let u2 = rgba[i] & 255;
      bytes.push(u2);
      a = (a + u2) % 65521;
      b = (b + a) % 65521;
    }
  }
  bytes.push(
    b >> 8,
    b & 255,
    a >> 8,
    a & 255,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    73,
    69,
    78,
    68,
    174,
    66,
    96,
    130
  );
  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {
    let c = ~0;
    for (let i = start; i < end; i++) {
      c ^= bytes[i];
      c = c >>> 4 ^ table[c & 15];
      c = c >>> 4 ^ table[c & 15];
    }
    c = ~c;
    bytes[end++] = c >>> 24;
    bytes[end++] = c >> 16 & 255;
    bytes[end++] = c >> 8 & 255;
    bytes[end++] = c & 255;
  }
  return "data:image/png;base64," + btoa(String.fromCharCode(...bytes));
}
function thumbHashToDataURL(hash) {
  let image = thumbHashToRGBA(hash);
  return rgbaToDataURL(image.w, image.h, image.rgba);
}

// node_modules/@splinetool/react-spline/dist/next/decodePreview.js
function X(t, i = false, o2 = 100, c = 100) {
  return i ? thumbHashToDataURL(N(t)) : O(t, o2, c);
}
function N(t) {
  return new Uint8Array(
    atob(t).split("").map((i) => i.charCodeAt(0))
  );
}
function O(t, i = 100, o2 = 100) {
  if (!t)
    return;
  const c = j(t, i, o2);
  return M2(c, i, o2);
}
function M2(t, i, o2) {
  const c = [...t].map((d2) => String.fromCharCode(d2)).join(""), l2 = B(i, o2, c);
  return "data:image/png;base64," + (typeof Buffer < "u" ? Buffer.from(x2(l2)).toString("base64") : btoa(l2));
}
function x2(t) {
  const i = new Uint8Array(t.length);
  for (let o2 = 0; o2 < t.length; o2++)
    i[o2] = t.charCodeAt(o2);
  return i;
}
function B(t, i, o2) {
  const c = "x", l2 = [], T = `Â‰PNG\r

`, d2 = "\0";
  let C3, s, h3;
  for (C3 = 0; C3 < 256; C3++) {
    for (s = C3, h3 = 0; h3 < 8; h3++)
      s & 1 ? s = 3988292384 ^ s >>> 1 : s = s >>> 1;
    l2[C3] = s;
  }
  function E(r) {
    let n = "", e, f2;
    for (let g = 0; g < r.length; g += 65535)
      e = r.length - g, f2 = "", e <= 65535 ? f2 = "" : (e = 65535, f2 = "\0"), n += f2 + String.fromCharCode(e & 255, (e & 65280) >>> 8), n += String.fromCharCode(
        ~e & 255,
        (~e & 65280) >>> 8
      ), n += r.substring(g, g + e);
    return n;
  }
  function p2(r) {
    let a = 65521, n = 1, e = 0;
    for (let f2 = 0; f2 < r.length; f2++)
      n = (n + r.charCodeAt(f2)) % a, e = (e + n) % a;
    return e << 16 | n;
  }
  function D(r, a) {
    let n = r, e;
    for (let f2 = 0; f2 < a.length; f2++)
      e = a.charCodeAt(f2), n = l2[(n ^ e) & 255] ^ n >>> 8;
    return n;
  }
  function L2(r) {
    return D(4294967295, r) ^ 4294967295;
  }
  function u2(r) {
    return String.fromCharCode(
      (r & 4278190080) >>> 24,
      (r & 16711680) >>> 16,
      (r & 65280) >>> 8,
      r & 255
    );
  }
  function S(r, a, n) {
    const e = L2(a + n);
    return u2(r) + a + n + u2(e);
  }
  function H(r, a) {
    const n = u2(r) + u2(a) + // bit depth
    "\b\0\0\0";
    return S(13, "IHDR", n);
  }
  const _ = S(0, "IEND", ""), I = H(t, i);
  let A = "", m;
  for (let r = 0; r < o2.length; r += t * 4) {
    if (m = d2, Array.isArray(o2))
      for (let a = 0; a < t * 4; a++)
        m += String.fromCharCode(o2[r + a] & 255);
    else
      m += o2.substr(r, t * 4);
    A += m;
  }
  const R = c + E(A) + u2(p2(A)), b = S(
    R.length,
    "IDAT",
    R
  );
  return T + I + b + _;
}

// node_modules/@splinetool/react-spline/dist/react-spline-next.js
var import_image = __toESM(require_react_spline());
async function l(n) {
  const t = /^https:\/\/([^\/]+).spline.design\/([^\/]+)\/scene.splinecode/gi.exec(
    n
  );
  let i = {};
  if (t != null && t[2]) {
    const s = t[1], r = t[2];
    try {
      const e = await (await fetch(`https://${s}.spline.design/${r}/hash`, {
        cache: false ? "force-cache" : "no-store"
      })).json();
      Object.assign(i, e), i.img = X(e.hash, e.alpha, e.width, e.height);
    } catch (c) {
      console.error(c);
    }
  }
  return i;
}
async function u({ ...n }) {
  const {
    hash: t,
    img: i,
    frameWidth: s,
    frameHeight: r,
    width: c,
    height: e
  } = await l(n.scene);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(C, { ...n, children: i && (0, import_jsx_runtime.jsx)(
    import_image.default,
    {
      src: i,
      alt: "Spline preview",
      style: {
        width: s ? s + "px" : "100%",
        height: r ? r + "px" : "100%"
      },
      width: c ?? 100,
      height: e ?? 100
    }
  ) }) });
}
export {
  u as default
};
//# sourceMappingURL=@splinetool_react-spline_next.js.map
